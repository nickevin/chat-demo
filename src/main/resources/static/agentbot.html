<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title>客户端调试工具</title>
  <script>
    const windowsLocation = window.location.protocol + '//' + window.location.host;
    const defaultAssistantSettings = {
        model: "community-finance-qwen3",
        isStreaming: false,
        systemInstruction: "",
        temperature: 0.9,
        topP: 0.8,
        topK: 15,
        repetitionPenalty: 1.0,
        streamingEndpoint: windowsLocation + "/chat/streaming",
        nonStreamingEndpoint: windowsLocation + "/chat"
    };
    const defaultUserSettings = {
        model: "community-finance-qwen3",
        isStreaming: false,
        systemInstruction: "",
        temperature: 0.5,
        topP: 0.5,
        topK: 10,
        repetitionPenalty: 1.5,
        streamingEndpoint: windowsLocation + "/chat/streaming",
        nonStreamingEndpoint: windowsLocation + "/chat"
    };
  </script>
  <script src="script/jquery@3.7.1.js"></script>
  <script src="script/tailwindcss@3.4.16.js"></script>
  <script src="script/marked@15.0.11.js"></script>
  <link href="style/fontawesome.min.css" rel="stylesheet">
  <style>
    body {
        font-family: "SF Pro Text", "SF Pro Icons", "Helvetica Neue", "Helvetica", "Arial", sans-serif;
        color: #1d1d1f;
    }
    body.body-no-scroll {
        overflow: hidden;
    }
    .is-hidden {
        display: none !important;
    }
    ::-webkit-scrollbar {
        width: 6px;
        height: 6px;
    }
    ::-webkit-scrollbar-track {
        background: transparent;
    }
    ::-webkit-scrollbar-thumb {
        background: rgba(0, 0, 0, 0.25);
        border-radius: 3px;
    }
    ::-webkit-scrollbar-thumb:hover {
        background: rgba(0, 0, 0, 0.35);
    }
    .sidebar {
        background-color: #F2F2F7;
        border-right: 1px solid #d2d2d7;
        transition: transform 0.35s cubic-bezier(0.4, 0, 0.2, 1);
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        width: 250px;
        overflow: auto;
        z-index: 20;
    }
    .sidebar.collapsed {
        transform: translateX(-100%);
    }
    .main-content {
        margin-left: 260px;
        transition: margin-left 0.35s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .sidebar.collapsed~.main-content {
        margin-left: 0;
    }
    .header-container {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
    }
    .header-content {
        display: flex;
        align-items: center;
        gap: 16px;
    }
    .input-container {
        max-width: 800px;
        margin: 0 auto;
        width: calc(100% - 28px);
        display: flex;
        align-items: center;
        background-color: white;
        padding: 8px 16px;
    }
    #message-input {
        font-size: 15px;
        resize: none;
        overflow: hidden;
        flex-grow: 1;
    }
    #message-input:focus {
        outline: none;
    }
    #new-chat-btn.disabled {
        opacity: 0.5;
        pointer-events: none;
    }
    #send-btn {
        transition: background-color 0.2s cubic-bezier(0.4, 0, 0.2, 1), transform 0.15s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.2s ease;
        position: absolute;
        bottom: 4px;
        right: 0px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        border: none;
        cursor: pointer;
    }
    #send-btn:active:not(:disabled) {
        transform: scale(0.9);
        transition-duration: 0.05s;
    }
    #send-btn:disabled {
        transform: scale(1);
        opacity: 0.6 !important;
        cursor: default;
    }
    #send-btn .fa-paper-plane {
        display: inline-block;
    }
    #send-btn.sending .fa-paper-plane {
        display: none;
    }
    #send-btn.sending .sending-spinner {
        display: inline-block;
    }
    .sending-spinner {
        display: none;
        width: 20px;
        height: 20px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-top-color: #ffffff;
        border-radius: 50%;
        animation: spin 0.7s linear infinite;
    }
    .user-profile-btn {
        background-color: #f0f0f0;
        border: none;
        border-radius: 10px;
        padding: 8px 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background-color 0.2s ease, transform 0.1s ease;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
    }
    .user-profile-btn:hover {
        background-color: #e0e0e0;
        transform: translateY(-1px);
    }
    .user-profile-btn:active {
        transform: scale(0.98);
        background-color: #d0d0d0;
    }
    .edit-buttons {
        display: flex;
        gap: 8px;
        margin-top: 8px;
        justify-content: flex-end;
        position: absolute;
        bottom: 18px;
        right: 12px;
    }
    .edit-button {
        padding: 8px 14px;
        border-radius: 10px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: background-color 0.2s cubic-bezier(0.4, 0, 0.2, 1), color 0.2s cubic-bezier(0.4, 0, 0.2, 1), border-color 0.2s cubic-bezier(0.4, 0, 0.2, 1), transform 0.1s ease;
    }
    .edit-button:active {
        transform: scale(0.95);
    }
    .save-button {
        background-color: #007AFF;
        color: white;
        border: none;
        box-shadow: 0 2px 8px rgba(0, 122, 255, 0.2);
    }
    .save-button:hover {
        background-color: #006FE6;
    }
    .cancel-button {
        background-color: #E5F1FF;
        color: #007aff;
        border: none;
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.05);
    }
    .cancel-button:hover {
        background-color: white;
    }
    #start-chat-btn {
        background-color: #007aff;
        color: white;
        border-radius: 10px;
        padding: 12px 20px;
        font-size: 17px;
        font-weight: 600;
        transition: background-color 0.2s cubic-bezier(0.4, 0, 0.2, 1), transform 0.15s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 0 2px 8px rgba(0, 122, 255, 0.2);
    }
    #start-chat-btn:hover:not(:disabled) {
        background-color: #006fe6;
        box-shadow: 0 4px 12px rgba(0, 122, 255, 0.3);
    }
    #start-chat-btn:active:not(:disabled) {
        transform: scale(0.95);
        background-color: #005bb5;
        transition-duration: 0.05s;
        box-shadow: 0 1px 4px rgba(0, 122, 255, 0.2);
    }
    #start-chat-btn:disabled {
        background-color: #e5e5ea !important;
        color: #b0b0b5 !important;
        cursor: default;
        box-shadow: none;
    }
    .edit-textarea {
        padding: 10px 15px;
        border-radius: 12px;
        border: 1px solid #d2d2d7;
        font-size: 15px;
        min-height: 100px;
        min-width: 250px;
        width: 100%;
        box-sizing: border-box;
        transition: border-color 0.2s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .edit-textarea:focus {
        border-color: #007aff;
        box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.25);
        outline: none;
    }
    #username-input {
        border-radius: 10px;
        padding: 12px 16px;
        font-size: 16px;
        border: 1px solid #d2d2d7;
        transition: border-color 0.2s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }
    #username-input:focus {
        border-color: #007aff;
        box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.25);
        outline: none;
    }
    .edit-name-input {
        display: none;
        width: 100%;
        padding: 6px 10px;
        border: 1px solid #d2d2d7;
        font-size: 13px;
    }
    .edit-name-input:focus {
        border-color: #007aff;
        box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.3);
        outline: none;
    }
    #confirm-modal,
    #user-login-modal {
        backdrop-filter: blur(5px);
    }
    .modal-content {
        border-radius: 16px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15), 0 4px 12px rgba(0, 0, 0, 0.08);
    }
    .modal-enter .modal-content {
        animation: modalFadeIn 0.3s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
    }
    .modal-exit .modal-content {
        animation: modalFadeOut 0.25s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
    }
    #confirm-modal.modal-enter,
    #confirm-modal.modal-exit {
        display: flex;
    }
    .notification-container {
        position: fixed;
        top: 1rem;
        right: 1rem;
        z-index: 100;
    }
    .notification {
        border-radius: 12px;
        padding: 14px 18px;
        backdrop-filter: blur(10px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        max-width: 80%;
        margin: 0 auto 14px auto;
        display: flex;
        align-items: center;
        border: 1px solid;
        opacity: 0;
        transform: translateY(10px) scale(0.95);
        transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1), transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        min-width: 300px;
        max-width: 500px;
        white-space: pre-wrap;
        word-break: break-word;
    }
    .notification.show {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
    .notification i {
        margin-right: 8px;
    }
    .notification.success {
        background-color: rgba(52, 199, 89, 0.15);
        border-color: rgba(52, 199, 89, 0.25);
        color: #34C759;
    }
    .notification.warning {
        background-color: rgba(255, 204, 0, 0.15);
        border-color: rgba(255, 204, 0, 0.25);
        color: #FFCC00;
    }
    .notification.error {
        background-color: rgba(255, 59, 48, 0.15);
        border-color: rgba(255, 59, 48, 0.25);
        color: #FF3B30;
    }
    .notification.info {
        background-color: rgba(0, 122, 255, 0.15);
        border-color: rgba(0, 122, 255, 0.25);
        color: #007AFF;
    }
    #chat-container {
        scroll-behavior: smooth;
        padding: 16px;
    }
    .user-message {
        background-color: #0090FF;
        color: white;
        border-radius: 18px 5px 18px 18px;
        cursor: pointer;
        transition: background-color 0.25s ease, transform 0.2s ease;
        padding: 5px 10px;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        min-width: 80px;
    }
    .user-message:hover {
        background-color: #0A84FF;
    }
    .assistant-message {
        background-color: #E5E5EA;
        border-radius: 5px 18px 18px 18px;
        padding: 10px 15px;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        transition: background-color 0.25s ease, transform 0.2s ease;
    }
    .assistant-message:hover {
        background-color: #D8D8DC;
    }
    .avatar {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 15px;
        flex-shrink: 0;
    }
    .user-avatar, .assistant-avatar {
        background-color: #e5e5ea;
        color: #636366;
    }
    .user-avatar-small {
        background-color: #e5e5ea;
        color: #636366;
        width: 28px;
        height: 28px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
        font-size: 14px;
    }
    .user-avatar-large {
        background-color: #e5e5ea;
        color: #636366;
        font-size: 48px;
        font-weight: 700;
        width: 92px;
        height: 92px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
        box-shadow: 0 3px 10px rgba(0, 0, 0, 0.07);
    }
    .spinner {
        color: #8e8e93;
    }
    .assistant-think-container, .user-think-container {
        border-radius: 10px;
        padding: 8px 12px;
        position: relative;
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.05);
    }
    .assistant-think-container {
        background-color: #EBEBF0;
    }
    .user-think-container {
        background-color: #419CFF;
    }
    .assistant-think-content, .user-think-content {
        display: none;
        padding: 6px 0;
        font-size: 0.9em;
    }
    .assistant-think-content {
        color: #333;
    }
    .user-think-content {
        color:white;
    }
    .assistant-think-content.show, .user-think-content.show {
        display: block;
    }
    .assistant-think-toggle {
        cursor: pointer;
        font-size: 0.85em;
        display: flex;
        align-items: center;
        font-weight: 600;
    }
    .assistant-think-toggle i {
        margin-right: 4px;
        transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .assistant-think-toggle.open i {
        transform: rotate(90deg);
    }
    .user-think-toggle {
        color: white;
    }
    .normal-content {
    }
    .normal-content:first-child {
        margin-top: 0;
        border-top: none;
        padding-top: 0;
    }
    .assistant-think-container + .normal-content,
    .user-think-container + .normal-content {
      padding-top: 10px;
    }
    .normal-content.is-empty-placeholder {
        display: none;
    }
    .history-item {
        transition: background-color 0.2s cubic-bezier(0.4, 0, 0.2, 1), border-left-color 0.2s cubic-bezier(0.4, 0, 0.2, 1), transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        margin-bottom: 4px;
        padding: 10px 14px;
    }
    .history-item:hover {
        background-color: rgba(0, 122, 255, 0.08);
        cursor: pointer;
    }
    .history-item.active {
        background-color: rgba(0, 122, 255, 0.12);
        border-left: 3px solid #007aff;
        font-weight: 600;
        cursor: pointer;
    }
    .history-item .history-name {
        font-size: 13px;
    }
    .history-item.editing .edit-name-input {
        display: block;
    }
    .history-item.editing .history-name {
        display: none;
    }
    .delete-btn {
        color: #ff3b30;
        opacity: 0;
        transition: opacity 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        padding: 4px 7px;
        border-radius: 6px;
        background-color: rgba(255, 59, 48, 0.05);
    }
    .edit-btn {
        color: #007aff;
        opacity: 0;
        transition: opacity 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        padding: 4px 7px;
        border-radius: 6px;
        background-color: rgba(0, 122, 255, 0.05);
    }
    .history-item:hover .edit-btn,
    .history-item:hover .delete-btn {
        opacity: 1;
    }
    .history-section {
        margin-top: 12px;
    }
    .history-section-name {
        font-size: 13px;
        font-weight: 600;
        color: #86868b;
        text-transform: none;
        letter-spacing: 0;
        padding: 10px 14px;
        margin-top: 8px;
    }
    .history-empty-state {
        text-align: center;
        color: #86868b;
        padding: 24px 14px;
        font-size: 14px;
    }
    .history-empty-icon {
        font-size: 26px;
        margin-bottom: 8px;
    }
    .settings-panel {
        position: fixed;
        top: 0;
        right: 0;
        bottom: 0;
        width: 420px;
        min-width: 420px;
        max-width: 550px;
        overflow: auto;
        background-color: white;
        z-index: 40;
        transform: translateX(100%);
        transition: transform 0.35s cubic-bezier(0.4, 0, 0.2, 1);
        border-left: none;
        box-shadow: 0 3px 14px rgba(0, 0, 0, 0.07);
    }
    .settings-panel.open {
        transform: translateX(0);
    }
    .settings-header {
        padding: 20px;
        border-bottom: 1px solid #e5e5ea;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .settings-content {
        padding: 20px;
        overflow-y: auto;
        height: calc(100% - 65px);
    }
    .settings-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.35);
        z-index: 35;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.35s cubic-bezier(0.4, 0, 0.2, 1);
        backdrop-filter: blur(4px);
    }
    .settings-overlay.open {
        opacity: 1;
        pointer-events: auto;
    }
    .settings-form-group {
        margin-bottom: 20px;
    }
    .settings-label {
        display: block;
        margin-bottom: 8px;
        font-size: 14px;
        color: #1d1d1f;
    }
    .settings-input,
    .settings-panel select {
        width: 100%;
        padding: 10px 14px;
        border: 1px solid #d2d2d7;
        border-radius: 10px;
        font-size: 14px;
        transition: border-color 0.2s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .settings-input:focus,
    .settings-panel select:focus {
        border-color: #007aff;
        outline: none;
        box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.2);
    }
    .settings-textarea {
        min-height: 100px;
        resize: vertical;
    }
    .settings-param-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
    }
    .settings-param-group {
        margin-bottom: 12px;
    }
    .settings-tabs {
        display: flex;
        padding: 6px;
        background-color: #e5e5ea;
        border-radius: 10px;
        margin: 20px;
        box-shadow: inset 0 0 0 0.5px rgba(0, 0, 0, 0.08);
    }
    .settings-tabs .tab-button {
        flex: 1;
        padding: 8px 12px;
        font-size: 14px;
        font-weight: 500;
        color: #636366;
        background-color: transparent;
        border: none;
        cursor: pointer;
        transition: background-color 0.2s cubic-bezier(0.4, 0, 0.2, 1), color 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        text-align: center;
    }
    .settings-tabs .tab-button.active {
        background-color: white;
        color: #1d1d1f;
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
    }
    .settings-tabs .tab-button:hover:not(.active) {
        background-color: rgba(0, 0, 0, 0.04);
    }
    .settings-details summary {
        cursor: pointer;
        padding: 10px 0;
        font-weight: 600;
        font-size: 15px;
        color: #1d1d1f;
        display: flex;
        align-items: center;
        list-style: none;
    }
    .settings-details summary::-webkit-details-marker {
        display: none;
    }
    .settings-details summary:before {
        content: '\f078';
        font-family: "Font Awesome 5 Free";
        font-weight: 900;
        margin-right: 8px;
        transition: transform 0.2s ease;
    }
    .settings-details[open] summary:before {
        transform: rotate(180deg);
    }
    .settings-details-content {
        padding-top: 10px;
        padding-bottom: 10px;
    }
    .settings-panel button {
        border-radius: 10px;
        transition: background-color 0.2s ease, transform 0.1s ease, color 0.2s ease, border-color 0.2s ease;
    }
    .settings-panel button:active:not(:disabled) {
        transform: scale(0.96);
    }
    #save-settings-btn {
        padding: 12px 18px;
        font-weight: 600;
    }
    #save-settings-btn:hover:not(:disabled) {
        background-color: #0056b3;
    }
    .stream-toggle {
        position: relative;
        display: inline-block;
        width: 52px;
        height: 30px;
    }
    .stream-toggle input {
        opacity: 0;
        width: 0;
        height: 0;
    }
    .stream-toggle-slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #e5e5ea;
        transition: .4s cubic-bezier(0.4, 0, 0.2, 1);
        border-radius: 30px;
    }
    .stream-toggle-slider:before {
        position: absolute;
        content: "";
        height: 26px;
        width: 26px;
        left: 2px;
        bottom: 2px;
        background-color: white;
        transition: .4s cubic-bezier(0.4, 0, 0.2, 1);
        border-radius: 50%;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }
    .stream-toggle input:checked+.stream-toggle-slider {
        background-color: #34C759;
    }
    .stream-toggle input:checked+.stream-toggle-slider:before {
        transform: translateX(22px);
    }
    .stream-toggle-text {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        font-size: 11px;
        font-weight: 600;
        color: #fff;
        pointer-events: none;
        transition: opacity 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .stream-toggle-text.on {
        left: 7px;
        opacity: 0;
    }
    .stream-toggle-text.off {
        right: 7px;
        opacity: 1;
    }
    .stream-toggle input:checked~.stream-toggle-text.on {
        opacity: 1;
    }
    .stream-toggle input:checked~.stream-toggle-text.off {
        opacity: 0;
    }
    .stream-toggle-tooltip {
        position: absolute;
        bottom: -24px;
        left: 50%;
        transform: translateX(-50%);
        background-color: #1d1d1f;
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .stream-toggle:hover .stream-toggle-tooltip {
        opacity: 1;
    }
    .model-selector {
        position: relative;
        display: inline-block;
        width: 100%;
    }
    .model-selector-btn {
        background-color: white;
        border: 1px solid #d2d2d7;
        border-radius: 10px;
        padding: 10px 14px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        width: 100%;
        cursor: pointer;
        transition: background-color 0.2s ease, box-shadow 0.2s ease;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
    }
    .model-selector-btn:hover {
        background-color: #f5f5f7;
    }
    .model-selector-options {
        position: absolute;
        top: calc(100% + 8px);
        left: 0;
        background-color: white;
        border: 1px solid #d2d2d7;
        border-radius: 12px;
        width: 100%;
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
        z-index: 10;
        opacity: 0;
        transform: translateY(-8px) scale(0.98);
        transform-origin: top;
        transition: opacity 0.2s cubic-bezier(0.4, 0, 0.2, 1), transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        pointer-events: none;
    }
    .model-selector.open .model-selector-options {
        opacity: 1;
        transform: translateY(0) scale(1);
        pointer-events: auto;
    }
    .model-selector-option {
        padding: 12px 16px;
        cursor: pointer;
        transition: background-color 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        margin: 4px 8px;
    }
    .model-selector-option:hover {
        background-color: rgba(0, 122, 255, 0.1);
    }
    .model-selector-option.selected {
        background-color: rgba(0, 122, 255, 0.1);
        border-left: 3px solid #007aff;
        font-weight: 600;
    }
    .model-name {
        font-weight: 600;
    }
    .model-description {
        font-size: 12px;
        color: #86868b;
        margin-top: 4px;
    }
    @media (max-width: 768px) {
        .sidebar {
            width: 100%;
            position: fixed;
            z-index: 100;
            transform: translateX(-100%);
        }
        .sidebar.collapsed {
            transform: translateX(-100%);
        }
        .sidebar:not(.collapsed) {
            transform: translateX(0);
        }
        .main-content {
            margin-left: 0 !important;
        }
        #chat-container {
            padding: 1rem !important;
        }
        .input-container {
            width: 100% !important;
            padding: 0.75rem 0.75rem !important;
        }
        .input-container #settings-btn {
            margin-left: 0.25rem;
        }
        .input-container .ml-2 {
           margin-left: 0.5rem !important;
        }
         .input-container .md\:ml-3 {
           margin-left: 0.5rem !important;
        }
        .message-input-container {
            flex-direction: column;
            gap: 0.5rem;
        }
        #message-input {
            width: 100%;
        }
        #send-btn {
            width: 100%;
            margin-left: 0 !important;
            height: 44px;
        }
        .user-message,
        .assistant-message-wrapper {
            max-width: 92%;
        }
        .settings-panel {
            width: 100%;
            min-width: unset;
            max-width: unset;
            border-left: none;
        }
        .settings-param-grid {
            grid-template-columns: 1fr;
        }
        .settings-tabs {
             margin: 1rem;
        }
    }
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    @keyframes modalFadeIn {
        0% { opacity: 0; transform: scale(0.95); }
        100% { opacity: 1; transform: scale(1); }
    }
    @keyframes modalFadeOut {
        0% { opacity: 1; transform: scale(1); }
        100% { opacity: 0; transform: scale(0.95); }
    }
  </style>
</head>
<body class="bg-white h-screen overflow-hidden">
<div class="sidebar flex flex-col h-full" id="sidebar">
  <div class="p-9 border-b border-gray-200 flex justify-center items-center h-[60px]">
    <button class="bg-[#007aff] text-white px-4 py-2.5 rounded-lg flex items-center space-x-2 shadow-md hover:bg-[#006fe6] transition-all duration-200 h-[40px]"
            id="new-chat-btn">
      <i class="fas fa-plus text-sm"></i>
      <span class="text-base font-medium">新建对话</span>
    </button>
  </div>
  <div class="flex-1 overflow-y-auto p-2.5" id="history-list">
  </div>
</div>
<div class="main-content flex flex-col h-full">
  <div class="bg-white border-b p-4">
    <div class="header-container">
      <div class="flex items-center gap-3">
        <button aria-label="Toggle sidebar" class="user-profile-btn flex items-center justify-center h-[40px] w-[40px] p-0" id="sidebar-toggle-btn">
          <i class="fas fa-bars text-lg"></i>
        </button>
      </div>
      <div class="flex-1 text-center px-3">
        <h2 class="text-lg font-semibold text-gray-800 truncate" id="chat-title">新对话</h2>
      </div>
      <button class="user-profile-btn flex items-center space-x-2 h-[40px]" id="user-profile-btn">
        <div class="user-avatar-small">
          <i class="fas fa-user"></i>
        </div>
        <span class="font-medium text-sm" id="current-username"></span>
      </button>
    </div>
  </div>
  <div class="flex-1 overflow-y-auto p-4 space-y-4" id="chat-container">
  </div>
  <div class="bg-white">
    <div class="input-container flex flex-col items-center bg-white border border-gray-300 rounded-xl focus-within:ring-2 focus-within:ring-blue-500 focus-within:ring-offset-1 focus-within:ring-offset-white transition-all duration-150 mx-auto my-2" style="min-height: 50px; padding: 4px 8px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);">
      <div class="w-full flex justify-between items-center mb-0">
        <button id="settings-btn" title="对话设置" class="flex-shrink-0 p-1 rounded-full text-gray-500 hover:text-gray-700 hover:bg-gray-100 active:bg-gray-200 transition-colors focus:outline-none flex items-center space-x-1">
          <i class="fas fa-cog text-base"></i>
          <span class="text-sm font-medium">对话设置</span>
        </button>
        <button id="new-chat-btn-bottom" title="新建对话" class="flex-shrink-0 p-1 rounded-full text-gray-500 hover:text-gray-700 hover:bg-gray-100 active:bg-gray-200 transition-colors focus:outline-none flex items-center space-x-1">
          <i class="fas fa-plus text-base"></i>
          <span class="text-sm font-medium">新建对话</span>
        </button>
      </div>
      <div class="w-full border-t border-gray-200 my-2"></div>
      <div class="w-full flex items-center bg-white rounded-xl relative" style="min-height: 44px;">
        <textarea id="message-input"
                  class="flex-1 w-full self-stretch bg-transparent focus:outline-none pl-2 pr-1 py-1 text-[15px] placeholder-gray-500 resize-none rounded-xl"
                  rows="1"
                  placeholder="Start a message..."></textarea>
        <button id="send-btn"
                class="flex-shrink-0 mr-1 my-0.5 rounded-[10px] text-white bg-blue-500 hover:bg-blue-600 active:bg-blue-700 transition-colors disabled:opacity-50 disabled:bg-gray-400 relative flex items-center justify-center focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-blue-500"
                style="width: 36px; height: 36px;">
          <i class="fas fa-paper-plane text-base"></i>
          <span class="sending-spinner"></span>
        </button>
      </div>
    </div>
  </div>
  <div class="fixed inset-0 bg-black/40 flex items-center justify-center hidden z-50" id="confirm-modal">
    <div class="modal-content bg-white p-6 max-w-sm w-full mx-4">
      <div class="flex justify-between items-center mb-4">
        <h3 class="text-lg font-semibold">删除对话</h3>
        <button class="text-gray-600 hover:text-gray-800 p-1.5 rounded-full hover:bg-gray-200" id="close-modal-btn">
          <i class="fas fa-times text-md"></i>
        </button>
      </div>
      <p class="mb-6 text-gray-700 text-[15px]">此对话将被永久删除，该操作不可撤销。</p>
      <div class="flex justify-end space-x-3">
        <button class="px-4 py-2 text-[#007aff] hover:bg-[#007aff]/10 rounded-lg transition-colors font-medium text-[15px]" id="cancel-delete-btn">取消</button>
        <button class="px-4 py-2 bg-[#ff3b30] text-white rounded-lg hover:bg-[#ff3b30]/90 transition-colors font-medium text-[15px]" id="confirm-delete-btn">删除</button>
      </div>
    </div>
  </div>
  <div class="fixed inset-0 bg-black/40 flex items-center justify-center hidden z-50" id="user-login-modal">
    <div class="modal-content bg-white p-8 max-w-md w-full mx-4 text-center">
      <div class="user-avatar-large mx-auto mb-6">
        <i class="fas fa-user"></i>
      </div>
      <h2 class="text-xl font-semibold mb-5 text-gray-800">输入你的用户名</h2>
      <input class="w-full mb-6 text-center text-lg" id="username-input" placeholder="例如：张三" type="text">
      <button class="w-full" id="start-chat-btn">
        开始聊天
      </button>
    </div>
  </div>
  <div class="settings-panel" id="settings-panel">
    <div class="settings-header">
      <h3 class="text-lg font-semibold">对话设置</h3>
      <div class="flex items-center gap-3">
        <button class="text-gray-600 hover:text-gray-800 p-1.5 rounded-full hover:bg-gray-100 transition-colors" id="close-settings-btn">
          <i class="fas fa-times text-md"></i>
        </button>
      </div>
    </div>
    <div class="settings-tabs">
      <button class="tab-button" data-tab="assistant">助手</button>
      <button class="tab-button" data-tab="user">用户</button>
    </div>
    <div class="settings-content px-5 pt-2">
      <div id="shared-settings-form" class="space-y-4">
        <div class="model-selector relative w-full">
          <label class="settings-label">对话模型</label>
          <div class="model-selector-btn flex items-center justify-between w-full bg-white border border-[#d2d2d7] rounded-[10px] px-3.5 py-2.5 cursor-pointer hover:bg-[#f5f5f7] transition-colors"
               id="model-selector-btn">
            <div class="flex-1">
              <div class="model-name font-medium text-sm" id="selected-model">community-finance-qwen3</div>
              <div class="model-description text-xs text-gray-500 mt-1">Qwen3</div>
            </div>
            <i class="fas fa-chevron-down text-sm text-gray-500 transition-transform duration-200"></i>
          </div>
          <div id="model-options-container"
               class="model-selector-options absolute z-10 mt-2 w-full bg-white border border-[#d2d2d7] rounded-[10px] shadow-[0_5px_14px_rgba(0,0,0,0.1)] py-1 transition-all duration-200 opacity-0 scale-95 origin-top">
          </div>
        </div>
        <div class="settings-form-group">
          <label class="settings-label">系统指令</label>
          <textarea class="settings-input settings-textarea" id="system-instruction-input" rows="5"></textarea>
        </div>
        <div class="settings-form-group">
          <div class="flex items-center justify-between">
            <label class="settings-label mb-0">流式输出
              <span class="text-xs text-gray-500 ml-2">是否启用流式输出</span>
            </label>
            <label class="stream-toggle">
              <input id="streaming-toggle" type="checkbox">
              <span class="stream-toggle-slider"></span>
              <span class="stream-toggle-text on">开</span>
              <span class="stream-toggle-text off">关</span>
            </label>
          </div>
        </div>
        <details class="settings-details" open>
          <summary>模型参数</summary>
          <div class="settings-details-content">
            <div class="settings-param-grid">
              <div class="settings-param-group">
                <label class="settings-label">温度</label>
                <input class="settings-input" id="temperature-input" placeholder="0.0 - 1.0" type="text" value="0.7">
                <p class="text-xs text-gray-500 mt-1">控制随机性 (0=确定性)</p>
              </div>
              <div class="settings-param-group">
                <label class="settings-label">Top P</label>
                <input class="settings-input" id="top-p-input" placeholder="0.0 - 1.0" type="text" value="1.0">
                <p class="text-xs text-gray-500 mt-1">核心采样阈值</p>
              </div>
              <div class="settings-param-group">
                <label class="settings-label">Top K</label>
                <input class="settings-input" id="top-k-input" placeholder="1 - 100" type="text" value="50">
                <p class="text-xs text-gray-500 mt-1">限制为前 K 个 token</p>
              </div>
              <div class="settings-param-group">
                <label class="settings-label">Repetition Penalty</label>
                <input class="settings-input" id="repetition-penalty-input" placeholder="-2.0 - 2.0" type="text" value="0.0">
                <p class="text-xs text-gray-500 mt-1">惩罚重复的 token</p>
              </div>
            </div>
          </div>
        </details>
        <details class="settings-details">
          <summary>API 设置</summary>
          <div class="settings-details-content">
            <div class="space-y-4">
              <div class="settings-form-group">
                <label class="settings-label">流式接口地址</label>
                <input class="settings-input" id="streaming-endpoint-input" type="text">
              </div>
              <div class="settings-form-group">
                <label class="settings-label">非流式接口地址</label>
                <input class="settings-input" id="non-streaming-endpoint-input" type="text">
              </div>
            </div>
          </div>
        </details>
      </div>
      <div class="mt-6 p-5 border-t border-gray-200">
        <button class="w-full bg-blue-600 text-white hover:bg-blue-700 transition-colors" id="save-settings-btn">保存</button>
      </div>
    </div>
  </div>
  <div class="settings-overlay" id="settings-overlay"></div>
  <template id="user-message-template">
    <div class="flex flex-col items-end mb-3" data-message-type="user">
      <div class="flex items-center space-x-2 mb-2">
        <div class="text-xs text-gray-500 user-name-display">You</div>
        <div class="avatar user-avatar"><i class="fas fa-user"></i></div>
      </div>
      <div class="max-w-[50%] relative">
        <div class="p-3 user-message markdown-body"></div>
        <div class="edit-message-container hidden">
          <div class="relative">
            <textarea class="edit-textarea" rows="4"></textarea>
            <div class="edit-buttons">
              <button class="edit-button cancel-button flex items-center justify-center"><i class="fas fa-times"></i></button>
              <button class="edit-button save-button flex items-center justify-center"><i class="fas fa-check"></i></button>
            </div>
          </div>
        </div>
        <div class="text-xs text-gray-500 mt-1 text-right relative group">
          <span class="timestamp"></span>
          <span class="elapsed-time ml-2"></span>
          <span class="streaming-status ml-2 px-1.5 py-0.5 rounded bg-gray-100 text-gray-600 text-xs"></span>
          <button
              class="resend-btn absolute inset-0 flex items-center justify-end pr-2 text-blue-600 opacity-0 group-hover:opacity-100 transition-opacity bg-white bg-opacity-75 backdrop-blur-sm rounded-md">
            <i class="fas fa-redo mr-0.5 text-xs"></i>重新发送
          </button>
        </div>
      </div>
    </div>
  </template>
  <template id="assistant-message-template">
    <div class="flex flex-col items-start mb-3 assistant-message-wrapper" data-message-type="assistant">
      <div class="flex items-center space-x-2 mb-2">
        <div class="avatar assistant-avatar"><i class="fas fa-robot"></i></div>
        <div class="text-xs text-gray-500 model-name-display">Assistant</div>
      </div>
      <div class="max-w-[50%] group">
        <div class="assistant-message markdown-body"></div>
        <div class="text-xs text-gray-500 mt-1 flex justify-between items-center">
          <div class="flex items-center">
            <span class="timestamp"></span>
            <span class="elapsed-time ml-2"></span>
            <span class="streaming-status ml-2 px-1.5 py-0.5 rounded bg-gray-100 text-gray-600 text-xs"></span>
          </div>
          <button class="auto-reply-button ml-2 text-blue-600 text-xs opacity-0 group-hover:opacity-100 transition-opacity duration-200">
            <i class="fas fa-reply mr-0.5"></i> 自动回复
          </button>
        </div>
      </div>
    </div>
  </template>
  <template id="history-item-template">
    <div class="history-item p-2.5 flex justify-between items-center group">
      <div class="flex-1 min-w-0">
        <div class="history-name truncate text-[13px]"></div>
        <input class="edit-name-input" maxlength="40" type="text">
      </div>
      <div class="flex items-center space-x-2">
        <span class="time-string text-xs font-medium text-gray-500 opacity-0 group-hover:opacity-100 transition-opacity"></span>
        <button class="delete-btn p-1 rounded-md hover:bg-gray-200 transition-colors">
          <i class="fas fa-trash text-xs"></i>
        </button>
      </div>
    </div>
  </template>
  <template id="history-section-template">
    <div class="history-section">
      <div class="history-section-name"></div>
    </div>
  </template>
  <template id="notification-template">
    <div class="notification">
      <i class="fas"></i>
      <span></span>
    </div>
  </template>
  <template id="initial-chat-empty-state-template">
    <div class="flex flex-col items-center justify-center h-full text-gray-500">
      <i class="fas fa-comment-dots text-4xl mb-4"></i>
      <p class="text-xl font-light">开始新的对话</p>
    </div>
  </template>
  <template id="history-list-empty-state-template">
    <div class="history-empty-state">
      <div class="history-empty-icon"><i class="fas fa-comments"></i></div>
      <p>暂无对话记录</p>
    </div>
  </template>
  <template id="collapsible-think-template">
    <div class="collapsible-think-container">
      <div class="collapsible-think-toggle">
        <i class="fas fa-chevron-right"></i>
        <span>深度思考</span>
      </div>
      <div class="collapsible-think-parsed-content"></div>
    </div>
  </template>
  <template id="notification-container-template">
    <div class="notification-container"></div>
  </template>
  <template id="model-selector-option-template">
    <div class="model-selector-option" data-value="">
      <div class="model-name font-medium text-sm"></div>
      <div class="model-description text-xs text-gray-500 mt-1"></div>
    </div>
  </template>
  <script>
    class Utils {
        static generateUuid() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => (c === 'x' ? Math.random() * 16 | 0 : (Math.random() * 16 | 0) & 0x3 | 0x8).toString(16));
        }
        static getEffectiveSetting(currentSettings, defaultSettings, key) {
            return currentSettings[key] !== undefined ? currentSettings[key] : defaultSettings[key];
        }
        static processThinkContent(content, role) {
            const thinkMatch = content.match(/<think>([\s\S]*?)<\/think>/);
            let originalRestContent = thinkMatch ? content.replace(thinkMatch[0], '').trim() : content.trim();
            let thinkBlockHTML = '';
            if (thinkMatch) {
                const thinkContent = thinkMatch[1].trim();
                if (thinkContent) {
                    const templateContent = $('#collapsible-think-template').prop('content');
                    if (!templateContent) {
                        console.error("#collapsible-think-template not found. Falling back to inline HTML.");
                        const thinkContainerClass = role === 'user' ? 'user-think-container' : 'assistant-think-container';
                        const thinkContentClass = role === 'user' ? 'user-think-content' : 'assistant-think-content';
                        const thinkToggleClass = 'assistant-think-toggle' + (role === 'user' ? ' user-think-toggle' : '');
                        thinkBlockHTML = `
                          <div class="${thinkContainerClass}">
                            <div class="${thinkToggleClass}">
                              <i class="fas fa-chevron-right"></i><span>深度思考</span>
                            </div>
                            <div class="${thinkContentClass}">${marked.parse(thinkContent)}</div>
                          </div>`;
                    } else {
                        const $clonedFragment = $(templateContent.cloneNode(true));
                        const $container = $clonedFragment.find('.collapsible-think-container');
                        $container.addClass(role === 'user' ? 'user-think-container' : 'assistant-think-container');
                        const $toggle = $clonedFragment.find('.collapsible-think-toggle');
                        $toggle.addClass('assistant-think-toggle');
                        if (role === 'user') {
                            $toggle.addClass('user-think-toggle');
                        }
                        const $parsedContent = $clonedFragment.find('.collapsible-think-parsed-content');
                        $parsedContent.addClass(role === 'user' ? 'user-think-content' : 'assistant-think-content');
                        $parsedContent.html(marked.parse(thinkContent));
                        thinkBlockHTML = $('<div>').append($clonedFragment).html();
                    }
                }
            }
            let normalContentHTML = '';
            if (originalRestContent) {
                normalContentHTML = `<div class="normal-content">${marked.parse(originalRestContent)}</div>`;
            } else if (thinkBlockHTML) {
                normalContentHTML = `<div class="normal-content is-empty-placeholder"></div>`;
            }
            const finalOutput = (thinkBlockHTML + normalContentHTML).trim();
            if (!finalOutput && content.trim()) {
                return marked.parse(content.trim());
            }
            return finalOutput;
        }
        static groupChatsByTime(chatsToGroup) {
            const now = new Date(), today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const yesterday = new Date(today); yesterday.setDate(yesterday.getDate() - 1);
            const last7Days = new Date(today); last7Days.setDate(last7Days.getDate() - 7);
            const last30Days = new Date(today); last30Days.setDate(last30Days.getDate() - 30);
            const grouped = { today: [], yesterday: [], last7Days: [], last30Days: [], older: [] };
            chatsToGroup.forEach(chat => {
                const chatDate = new Date(chat.createdAt);
                if (chatDate >= today) grouped.today.push(chat);
                else if (chatDate >= yesterday) grouped.yesterday.push(chat);
                else if (chatDate >= last7Days) grouped.last7Days.push(chat);
                else if (chatDate >= last30Days) grouped.last30Days.push(chat);
                else grouped.older.push(chat);
            });
            return grouped;
        }
        static debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func.apply(this, args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
    }
    class NotificationManager {
        constructor(app) {
            this.app = app;
            this.container = null;
            this.icons = { success: 'fa-check-circle', warning: 'fa-exclamation-triangle', error: 'fa-exclamation-circle', info: 'fa-info-circle' };
        }
        init() {
            const templateNode = $('#notification-container-template').prop('content');
            if (templateNode) {
              this.container = $(templateNode.cloneNode(true)).children().first().appendTo('body');
            } else {
              console.error("#notification-container-template not found. Creating div programmatically.");
              this.container = $('<div class="notification-container"></div>').appendTo('body');
            }
        }
        show(message, type = 'info', duration = 3000) {
            if (!this.container) {
              console.error("Notification container not initialized.");
              return;
            }
            const notificationElement = $(this.app.DOM.notificationTemplate);
            notificationElement.addClass(type).find('i').addClass(this.icons[type] || this.icons.info);
            notificationElement.find('span').text(message);
            notificationElement.appendTo(this.container);
            requestAnimationFrame(() => {
              requestAnimationFrame(() => {
                  notificationElement.addClass('show');
              });
            });
            setTimeout(() => {
                notificationElement.removeClass('show');
                setTimeout(() => {
                    notificationElement.remove();
                }, 300);
            }, duration);
        }
        success(message, duration = 3000) { this.show(message, 'success', duration); }
        error(message, duration = 3000) { this.show(message, 'error', duration); }
        warning(message, duration = 3000) { this.show(message, 'warning', duration); }
        info(message, duration = 3000) { this.show(message, 'info', duration); }
    }
    class DataManager {
        constructor(app) {
            this.app = app;
        }
        saveChats() {
            localStorage.setItem('chats', JSON.stringify(this.app.STATE.chats));
            localStorage.setItem('currentChatId', this.app.STATE.currentChatId);
        }
        getCurrentChat() {
            if (!this.app.STATE.currentChatId) return null;
            let chat = this.app.STATE.chats.find(c => c.id === this.app.STATE.currentChatId);
            if (!chat) {
                chat = {
                    id: this.app.STATE.currentChatId,
                    name: "新对话",
                    settings: $.extend(true, {}, defaultAssistantSettings),
                    userSettings: $.extend(true, {}, defaultUserSettings),
                    messages: [],
                    createdAt: new Date().toISOString()
                };
                this.app.STATE.chats.push(chat);
            }
            if (chat && !chat.userSettings) {
                chat.userSettings = $.extend(true, {}, defaultUserSettings);
            }
            return chat;
        }
        _getActiveSettingsContext(forUserTab = null) {
            const chat = this.getCurrentChat();
            const isUser = (forUserTab !== null) ? forUserTab : (this.app.STATE.currentSettingsTab === 'user');
            if (!chat) {
                return {
                    current: {},
                    defaultSet: isUser ? defaultUserSettings : defaultAssistantSettings,
                    settingsKey: isUser ? 'userSettings' : 'settings',
                    isUser: isUser
                };
            }
            if (isUser) {
                return {
                    current: chat.userSettings || {},
                    defaultSet: defaultUserSettings,
                    settingsKey: 'userSettings',
                    isUser: true
                };
            } else {
                return {
                    current: chat.settings || {},
                    defaultSet: defaultAssistantSettings,
                    settingsKey: 'settings',
                    isUser: false
                };
            }
        }
        loadChatSettings() {
            const chat = this.getCurrentChat();
            if (!chat) return;
            const { current, defaultSet } = this._getActiveSettingsContext();
            this.app.DOM.systemInstructionInput.val(Utils.getEffectiveSetting(current, defaultSet, 'systemInstruction'));
            this.app.DOM.temperatureInput.val(Utils.getEffectiveSetting(current, defaultSet, 'temperature'));
            this.app.DOM.topPInput.val(Utils.getEffectiveSetting(current, defaultSet, 'topP'));
            this.app.DOM.topKInput.val(Utils.getEffectiveSetting(current, defaultSet, 'topK'));
            this.app.DOM.repetitionPenaltyInput.val(Utils.getEffectiveSetting(current, defaultSet, 'repetitionPenalty'));
            this.app.DOM.streamingToggle.prop('checked', Utils.getEffectiveSetting(current, defaultSet, 'isStreaming'));
            this.app.DOM.streamingEndpointInput.val(current.streamingEndpoint || defaultSet.streamingEndpoint);
            this.app.DOM.nonStreamingEndpointInput.val(current.nonStreamingEndpoint || defaultSet.nonStreamingEndpoint);
            this.app.DOM.streamingEndpointInput.attr('placeholder', defaultSet.streamingEndpoint);
            this.app.DOM.nonStreamingEndpointInput.attr('placeholder', defaultSet.nonStreamingEndpoint);
            this.app.STATE.currentModel = Utils.getEffectiveSetting(current, defaultSet, 'model');
            this.app.ui.updateStreamToggleVisualState();
            this.app.DOM.selectedModelDisplay.text(this.app.STATE.currentModel);
            this.app.DOM.modelSelectorBtn.find('.model-description').text(this.app.MODEL_INFO[this.app.STATE.currentModel]?.description || "");
            if (this.app.DOM.modelOptions) {
                 this.app.DOM.modelOptions.removeClass('selected').filter(`[data-value="${this.app.STATE.currentModel}"]`).addClass('selected');
            }
        }
        saveCurrentChatSettings() {
            const chat = this.getCurrentChat();
            if (!chat) return;
            const { defaultSet, settingsKey, isUser } = this._getActiveSettingsContext();
            const oldSettings = $.extend(true, {}, chat[settingsKey] || {});
            let newSettings = {
                model: this.app.DOM.selectedModelDisplay.text(),
                isStreaming: this.app.DOM.streamingToggle.is(':checked'),
                systemInstruction: this.app.DOM.systemInstructionInput.val(),
                temperature: parseFloat(this.app.DOM.temperatureInput.val()),
                topP: parseFloat(this.app.DOM.topPInput.val()),
                topK: parseInt(this.app.DOM.topKInput.val()),
                repetitionPenalty: parseFloat(this.app.DOM.repetitionPenaltyInput.val()),
                streamingEndpoint: this.app.DOM.streamingEndpointInput.val(),
                nonStreamingEndpoint: this.app.DOM.nonStreamingEndpointInput.val()
            };
            newSettings.temperature = !isNaN(newSettings.temperature) ? newSettings.temperature : defaultSet.temperature;
            newSettings.topP = !isNaN(newSettings.topP) ? newSettings.topP : defaultSet.topP;
            newSettings.topK = !isNaN(newSettings.topK) && newSettings.topK > 0 ? newSettings.topK : defaultSet.topK;
            newSettings.repetitionPenalty = !isNaN(newSettings.repetitionPenalty) ? newSettings.repetitionPenalty : defaultSet.repetitionPenalty;
            newSettings.streamingEndpoint = newSettings.streamingEndpoint || defaultSet.streamingEndpoint;
            newSettings.nonStreamingEndpoint = newSettings.nonStreamingEndpoint || defaultSet.nonStreamingEndpoint;
            if (JSON.stringify(oldSettings) !== JSON.stringify(newSettings)) {
                chat[settingsKey] = newSettings;
                if (isUser) {
                    this.app.ui.notification.success('用户设置已保存');
                } else {
                    this.app.STATE.currentModel = newSettings.model;
                    this.app.ui.notification.success('助手设置已保存');
                }
                this.saveChats();
                if (this.app.DOM.settingsPanel.hasClass('open') && this.app.STATE.currentSettingsTab === (isUser ? 'user' : 'assistant')) {
                     this.loadChatSettings();
                }
            } else {
                this.app.ui.notification.warning('设置未更改');
            }
        }
        createNewChat() {
            const chatId = Utils.generateUuid();
            const newChat = {
                id: chatId,
                name: "新对话",
                settings: $.extend(true, {}, defaultAssistantSettings),
                userSettings: $.extend(true, {}, defaultUserSettings),
                messages: [],
                createdAt: new Date().toISOString()
            };
            this.app.STATE.chats.unshift(newChat);
            this.app.STATE.currentChatId = chatId;
            this.saveChats();
            this.app.ui.renderChatHistory();
            this.loadChatById(newChat.id);
            this.app.DOM.chatTitle.text(newChat.name);
        }
        loadChatById(chatId) {
            const chat = this.app.STATE.chats.find(c => c.id == chatId);
            if (!chat) return;
            this.app.STATE.currentChatId = chatId;
            this.app.ui.renderChatMessages(chat.messages);
            this.app.DOM.historyList.find('.history-item').removeClass('active').filter(`[data-chat-id="${chatId}"]`).addClass('active');
            this.app.STATE.isNewChat = chat.messages.length === 0;
            if (this.app.DOM.settingsPanel.hasClass('open')) {
                this.loadChatSettings();
            } else {
                const assistantContext = this._getActiveSettingsContext(false);
                this.app.STATE.currentModel = Utils.getEffectiveSetting(assistantContext.current, assistantContext.defaultSet, 'model');
                this.app.DOM.selectedModelDisplay.text(this.app.STATE.currentModel);
                this.app.DOM.modelSelectorBtn.find('.model-description').text(this.app.MODEL_INFO[this.app.STATE.currentModel]?.description || '');
                if (this.app.DOM.modelOptions) {
                     this.app.DOM.modelOptions.removeClass('selected').filter(`[data-value="${this.app.STATE.currentModel}"]`).addClass('selected');
                }
                const currentStreamingState = Utils.getEffectiveSetting(assistantContext.current, assistantContext.defaultSet, 'isStreaming');
                this.app.DOM.streamingToggle.prop('checked', currentStreamingState);
            }
            this.app.DOM.chatTitle.text(chat.name);
            this.saveChats();
            this.app.DOM.messageInput.trigger('focus');
        }
        confirmChatDeletion() {
            if (!this.app.STATE.chatToDelete) {
                this.app.ui.hideConfirmationModal();
                return;
            }
            this.app.STATE.chats = this.app.STATE.chats.filter(chat => chat.id !== this.app.STATE.chatToDelete);
            this.saveChats();
            if (this.app.STATE.currentChatId === this.app.STATE.chatToDelete) {
                this.app.STATE.currentChatId = null;
                if (this.app.STATE.chats.length > 0) {
                  const sortedChats = [...this.app.STATE.chats].sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
                  this.loadChatById(sortedChats[0].id);
                }
                else this.createNewChat();
            }
            this.app.ui.renderChatHistory();
            this.app.ui.hideConfirmationModal();
        }
        resendUserMessage(messageIndex) {
            const chat = this.getCurrentChat();
            if (!chat || messageIndex < 0 || messageIndex >= chat.messages.length) return;
            chat.messages = chat.messages.slice(0, messageIndex + 1);
            this.saveChats();
            this.app.ui.renderChatMessages(chat.messages);
            this.app.api.sendChatMessage(chat.messages[messageIndex].content, true);
        }
    }
    class UIManager {
        constructor(app) {
            this.app = app;
            this.notification = new NotificationManager(this.app);
        }
        _showModal(modalElement, manageBodyOverflow = false) {
            modalElement.removeClass('hidden modal-exit').addClass('modal-enter');
            if (manageBodyOverflow) $('body').addClass('body-no-scroll');
        }
        _hideModal(modalElement, manageBodyOverflow = false, onHiddenCallback) {
            modalElement.removeClass('modal-enter').addClass('modal-exit');
            modalElement.one('animationend', () => {
                modalElement.addClass('hidden').removeClass('modal-exit');
                if (onHiddenCallback) onHiddenCallback();
                if (manageBodyOverflow) {
                    $('body').removeClass('body-no-scroll');
                }
            });
        }
        adjustTextareaHeight() {
            const textarea = this.app.DOM.messageInput;
            if (!textarea || !textarea.length) return;
            textarea.css('height', 'auto');
            let scrollHeight = textarea[0].scrollHeight;
            const lineHeight = parseFloat(textarea.css('line-height')) || 20;
            const minHeight = lineHeight * 1;
            const maxHeight = lineHeight * 7;
            if (scrollHeight < minHeight) {
                scrollHeight = minHeight;
            } else if (scrollHeight > maxHeight) {
                scrollHeight = maxHeight;
                textarea.css('overflow-y', 'auto');
            } else {
                textarea.css('overflow-y', 'hidden');
            }
            textarea.css('height', scrollHeight + 'px');
        }
        updateStreamToggleVisualState() {
            if (this.app.DOM.streamingToggle.length) {
                const { current, defaultSet } = this.app.data._getActiveSettingsContext();
                this.app.DOM.streamingToggle.prop('checked', Utils.getEffectiveSetting(current, defaultSet, 'isStreaming'));
            }
        }
        showSettingsPanel() {
            if (!this.app.STATE.currentChatId) return;
            this.switchSettingsTab(this.app.STATE.currentSettingsTab);
            this.app.DOM.settingsPanel.addClass('open');
            this.app.DOM.settingsOverlay.addClass('open');
            $('body').addClass('body-no-scroll');
        }
        hideSettingsPanel() {
            this.app.DOM.settingsPanel.removeClass('open');
            this.app.DOM.settingsOverlay.removeClass('open');
            $('body').removeClass('body-no-scroll');
        }
        switchSettingsTab(tabName) {
            this.app.DOM.tabButtons.removeClass('active');
            this.app.DOM.tabButtons.filter(`[data-tab="${tabName}"]`).addClass('active');
            this.app.STATE.currentSettingsTab = tabName;
            this.app.data.loadChatSettings();
        }
        toggleModelSelectorDropdown(event) {
            event.stopPropagation();
            const isOpening = !this.app.DOM.modelSelector.hasClass('open');
            this.app.DOM.modelSelector.toggleClass('open');
            this.app.DOM.modelSelectorBtn.find('i').toggleClass('rotate-180', isOpening);
            if (isOpening) {
                const { current, defaultSet } = this.app.data._getActiveSettingsContext();
                const modelToSelect = Utils.getEffectiveSetting(current, defaultSet, 'model');
                if (this.app.DOM.modelOptions) {
                    this.app.DOM.modelOptions.removeClass('selected').filter(`[data-value="${modelToSelect}"]`).addClass('selected');
                }
            }
        }
        selectModelOption(modelValue) {
            this.app.DOM.selectedModelDisplay.text(modelValue);
            this.app.DOM.modelSelectorBtn.find('.model-description').text(this.app.MODEL_INFO[modelValue]?.description || '');
            this.app.DOM.modelSelector.removeClass('open');
            this.app.DOM.modelSelectorBtn.find('i').removeClass('rotate-180');
            if (this.app.DOM.modelOptions) {
                this.app.DOM.modelOptions.removeClass('selected').filter(`[data-value="${modelValue}"]`).addClass('selected');
            }
        }
        showConfirmationModal(chatIdToDelete) {
            this.app.STATE.chatToDelete = chatIdToDelete;
            this._showModal(this.app.DOM.confirmModal);
        }
        hideConfirmationModal() {
            this._hideModal(this.app.DOM.confirmModal, false, () => {
                this.app.STATE.chatToDelete = null;
            });
        }
        renderChatMessages(messages) {
            this.app.DOM.chatContainer.empty();
            if (messages.length === 0) {
                this.app.DOM.chatContainer.html(this.app.DOM.initialChatEmptyStateTemplate);
                return;
            }
            messages.forEach((message, index) => {
                let messageElement;
                if (message.role === 'user') {
                    messageElement = $(this.app.DOM.userMessageTemplate);
                    messageElement.attr('data-message-index', index);
                    messageElement.find('.user-message').html(Utils.processThinkContent(message.content, 'user'));
                    messageElement.find('.timestamp').text(message.timestamp ? new Date(message.timestamp).toLocaleString('zh-CN', { year: 'numeric', month: 'numeric', day: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false }) : '');
                    messageElement.find('.resend-btn').attr('data-message-index', index);
                    if (message.isAutoReply) {
                        messageElement.find('.user-name-display').text(message.model || 'Auto-Reply');
                        if (message.elapsedTime) {
                            messageElement.find('.elapsed-time').text(` · 耗时 ${message.elapsedTime}ms`);
                        }
                        messageElement.find('.streaming-status').text(message.isStreaming ? '流式' : '非流式');
                    } else {
                        messageElement.find('.user-name-display').text(this.app.STATE.currentUser || 'You');
                        messageElement.find('.elapsed-time').text('');
                        messageElement.find('.streaming-status').text('');
                    }
                } else {
                    messageElement = $(this.app.DOM.assistantMessageTemplate);
                    messageElement.attr('data-message-index', index);
                    const assistantMessageContentDiv = messageElement.find('.assistant-message');
                    const processedContent = Utils.processThinkContent(message.content, 'assistant');
                    assistantMessageContentDiv.html(processedContent);
                    if (message.content && message.content.includes("<think>")) {
                        const normalContentDiv = assistantMessageContentDiv.find('.normal-content');
                        if (normalContentDiv.length > 0) {
                          if (normalContentDiv.html().trim() === '') {
                             normalContentDiv.addClass('is-hidden');
                          } else {
                             normalContentDiv.removeClass('is-hidden');
                          }
                        }
                    }
                    messageElement.find('.model-name-display').text(message.model || 'Assistant');
                    messageElement.find('.timestamp').text(message.timestamp ? new Date(message.timestamp).toLocaleString('zh-CN', { year: 'numeric', month: 'numeric', day: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false }) : '');
                    if (message.elapsedTime) {
                        messageElement.find('.elapsed-time').text(` · 耗时 ${message.elapsedTime}ms`);
                    }
                     messageElement.find('.streaming-status').text(message.isStreaming ? '流式' : '非流式');
                }
                this.app.DOM.chatContainer.append(messageElement);
            });
            this.app.DOM.chatContainer.scrollTop(this.app.DOM.chatContainer[0].scrollHeight);
        }
        startEditUserMessage(userMessageDiv, messageIndex) {
            const messageContainer = userMessageDiv.closest('.max-w-\\[50\\%\\]');
            const editContainer = messageContainer.find('.edit-message-container');
            const textarea = editContainer.find('textarea.edit-textarea');
            const messageWidth = userMessageDiv.outerWidth();
            const messageHeight = userMessageDiv.outerHeight();
            textarea.css({
                width: messageWidth + 'px',
                height: messageHeight + 'px'
            });
            const currentMessages = this.app.data.getCurrentChat()?.messages;
            if (currentMessages && currentMessages[messageIndex]) {
                let rawContent = currentMessages[messageIndex].content;
                const thinkMatch = rawContent.match(/<think>[\s\S]*?<\/think>/);
                if (thinkMatch) rawContent = rawContent.replace(thinkMatch[0], '').trim();
                textarea.val(rawContent);
            }
            userMessageDiv.addClass('hidden');
            editContainer.removeClass('hidden');
            textarea.trigger('focus').on('blur.editUser', function (event) {
                if (!$(event.relatedTarget).closest('.edit-buttons').length) {
                    userMessageDiv.removeClass('hidden');
                    editContainer.addClass('hidden');
                    $(this).off('blur.editUser');
                }
            });
        }
        cancelEditUserMessage(buttonElement) {
            const editContainer = $(buttonElement).closest('.edit-message-container');
            const messageContainer = editContainer.closest('.max-w-\\[50\\%\\]');
            messageContainer.find('.user-message').removeClass('hidden');
            editContainer.addClass('hidden');
            editContainer.find('textarea.edit-textarea').off('blur.editUser');
        }
        saveEditedUserMessage(buttonElement, messageIndex) {
            const editContainer = $(buttonElement).closest('.edit-message-container');
            const textarea = editContainer.find('textarea.edit-textarea');
            const newContent = textarea.val().trim();
            if (!newContent) {
                this.app.ui.notification.error('消息内容不能为空');
                return;
            }
            const chat = this.app.data.getCurrentChat();
            if (chat && chat.messages[messageIndex]) {
                let originalFullContent = chat.messages[messageIndex].content;
                const thinkMatch = originalFullContent.match(/<think>[\s\S]*?<\/think>/);
                let finalContent = newContent;
                if (thinkMatch) finalContent = thinkMatch[0] + "\n" + newContent;
                if (chat.messages[messageIndex].content !== finalContent) {
                    chat.messages[messageIndex].content = finalContent;
                    this.app.data.resendUserMessage(messageIndex);
                }
                const messageContainer = editContainer.closest('.max-w-\\[50\\%\\]');
                messageContainer.find('.user-message').removeClass('hidden');
                editContainer.addClass('hidden');
                textarea.off('blur.editUser');
            }
        }
        renderChatHistory() {
            this.app.DOM.historyList.empty();
            const sortedChats = [...this.app.STATE.chats].sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
            if (!sortedChats || sortedChats.length === 0) {
                this.app.DOM.historyList.html(this.app.DOM.historyListEmptyStateTemplate);
                return;
            }
            const groupedChats = Utils.groupChatsByTime(sortedChats);
            const sectionNameMap = { today: '今天', yesterday: '昨天', last7Days: '过去7天', last30Days: '过去30天', older: '更早' };
            Object.keys(sectionNameMap).forEach(key => {
                const sectionChats = groupedChats[key];
                if (sectionChats.length === 0) return;
                const sectionElement = $(this.app.DOM.historySectionTemplate);
                sectionElement.find('.history-section-name').text(sectionNameMap[key]);
                sectionChats.forEach(chat => {
                    const historyItem = $(this.app.DOM.historyItemTemplate);
                    historyItem.attr('data-chat-id', chat.id);
                    if (chat.id === this.app.STATE.currentChatId) historyItem.addClass('active');
                    historyItem.find('.history-name').text(chat.name).attr('title', chat.name);
                    historyItem.find('.edit-name-input').val(chat.name);
                    historyItem.find('.time-string').text(new Date(chat.createdAt).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false }));
                    sectionElement.append(historyItem);
                });
                this.app.DOM.historyList.append(sectionElement);
            });
        }
        startEditingChatName(historyItemElement) {
            historyItemElement.addClass('editing').find('.edit-name-input').trigger('focus').trigger('select');
        }
        finishEditingChatName(historyItemElement) {
            const input = historyItemElement.find('.edit-name-input');
            const newName = input.val().trim();
            const chatId = historyItemElement.data('chat-id');
            const chat = this.app.STATE.chats.find(c => c.id === chatId);
            if (chat && newName && newName !== chat.name) {
                chat.name = newName;
                this.app.data.saveChats();
                historyItemElement.find('.history-name').text(newName).attr('title', newName);
                if (this.app.STATE.currentChatId === chatId) this.app.DOM.chatTitle.text(newName);
            }
            historyItemElement.removeClass('editing');
        }
        showUserLoginModal() {
            this._showModal(this.app.DOM.userLoginModal, true);
            this.app.DOM.usernameInput.val(this.app.STATE.currentUser || '');
            this.app.DOM.startChatBtn.prop('disabled', !this.app.DOM.usernameInput.val().trim());
            this.app.DOM.usernameInput.trigger('focus');
        }
        hideUserLoginModal() {
            this._hideModal(this.app.DOM.userLoginModal, true);
        }
        updateUserProfileAvatar(username) {
            if (username) {
                this.app.DOM.loggedInUsername.text(username);
            } else {
                this.app.DOM.loggedInUsername.text('');
            }
        }
    }
    class APIManager {
      constructor(app) {
          this.app = app;
      }
      async _makeApiRequest({ endpoint, requestData, isStreaming, onNonStreamSuccess, onStreamDelta, onStreamFinish, onError, onFinally }) {
          try {
              const response = await fetch(endpoint, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify(requestData)
              });
              if (!response.ok) {
                  let errorBody = "Could not read error body.";
                  try { errorBody = await response.text(); } catch (e) {}
                  throw new Error(`Network response was not ok: ${response.status} ${response.statusText}. Body: ${errorBody}`);
              }
              if (isStreaming) {
                  const reader = response.body.getReader();
                  const decoder = new TextDecoder();
                  let lineBuffer = '';
                  const readStream = async () => {
                      const { done, value } = await reader.read();
                      if (done) {
                          if (onStreamFinish) onStreamFinish({ status: 'done_by_client', delta: null });
                          return;
                      }
                      lineBuffer += decoder.decode(value, { stream: true });
                      let lines = lineBuffer.split('\n');
                      lineBuffer = lines.pop();
                      for (const line of lines) {
                          if (line.trim() === '' || line.trim() === 'data:') continue;
                          const jsonDataToParse = line.startsWith('data:') ? line.substring(5).trim() : line.trim();
                          try {
                              const parsed = JSON.parse(jsonDataToParse);
                              if (parsed.delta && parsed.status === 'delta') {
                                  if (onStreamDelta) onStreamDelta(parsed);
                              } else if (parsed.status === 'finish') {
                                  if (onStreamFinish) onStreamFinish(parsed);
                                  try { reader.cancel(); } catch(e) { console.warn("Error cancelling reader:", e); }
                                  return;
                              }
                          } catch (e) {
                              console.warn('Failed to parse JSON line in stream:', jsonDataToParse, e);
                          }
                      }
                      await readStream();
                  };
                  await readStream();
              } else {
                  const data = await response.json();
                  if (onNonStreamSuccess) onNonStreamSuccess(data);
              }
          } catch (error) {
              if (onError) onError(error);
          } finally {
              if (onFinally) onFinally();
          }
      }
      async _prepareAndSendApiRequest(isAutoReply = false, contentOverride = null, isResend = false, autoReplyMeta = null) {
          const chat = this.app.data.getCurrentChat();
          if (!chat) return;
          let messageContentForUserMessage;
          if (isAutoReply) {
          } else {
              messageContentForUserMessage = contentOverride !== null ? contentOverride : this.app.DOM.messageInput.val().trim();
              if (!messageContentForUserMessage && !isResend) {
                   return;
              }
              if (this.app.STATE.isWaitingForResponse && !isResend) return;
          }
          this.app.STATE.isWaitingForResponse = true;
          this.app.DOM.sendBtn.addClass('sending').prop('disabled', true);
          this.app.DOM.messageInput.prop('disabled', true);
          if (!isAutoReply) {
              if (!isResend) {
                  const userMessage = {
                      role: 'user',
                      content: messageContentForUserMessage,
                      timestamp: new Date().toISOString(),
                      sentTime: Date.now()
                  };
                  if (autoReplyMeta) {
                      userMessage.elapsedTime = autoReplyMeta.elapsedTime;
                      userMessage.isStreaming = autoReplyMeta.isStreaming;
                      userMessage.model = autoReplyMeta.model;
                      userMessage.isAutoReply = true;
                  }
                  chat.messages.push(userMessage);
                  if (chat.messages.length === 1 && messageContentForUserMessage) {
                      chat.name = messageContentForUserMessage.length > 25 ? messageContentForUserMessage.substring(0, 25) + '...' : messageContentForUserMessage;
                      this.app.ui.renderChatHistory();
                      this.app.DOM.chatTitle.text(chat.name);
                  }
              } else {
                  const lastUserMessage = chat.messages[chat.messages.length - 1];
                  if (lastUserMessage && lastUserMessage.role === 'user') {
                      lastUserMessage.timestamp = new Date().toISOString();
                      lastUserMessage.sentTime = Date.now();
                  }
              }
              this.app.data.saveChats();
              this.app.ui.renderChatMessages(chat.messages);
              if (contentOverride === null && !isResend) {
                  this.app.DOM.messageInput.val('');
                  localStorage.removeItem('draftMessage');
              }
              if (this.app.STATE.isNewChat && chat.messages.length > 0) this.app.STATE.isNewChat = false;
          }
          const settingsToUse = isAutoReply ? (chat.userSettings || defaultUserSettings) : (chat.settings || defaultAssistantSettings);
          const chatHistoryForAPI = (isAutoReply ? chat.messages : chat.messages.slice(0, -1))
              .map(message => ({
                  role: message.role,
                  content: message.content.replace(/<think>[\s\S]*?<\/think>/, '').trim()
              }));
          const latestUserQueryForAPI = isAutoReply ? "" : (chat.messages[chat.messages.length - 1]?.content.replace(/<think>[\s\S]*?<\/think>/, '').trim() || "");
          const requestData = {
              chatId: this.app.STATE.currentChatId,
              reqId: Utils.generateUuid(),
              query: latestUserQueryForAPI,
              messages: chatHistoryForAPI,
              settings: { ...settingsToUse },
              user: this.app.STATE.currentUser
          };
          const endpoint = settingsToUse.isStreaming ? settingsToUse.streamingEndpoint : settingsToUse.nonStreamingEndpoint;
          const isStreaming = settingsToUse.isStreaming;
          const requestStartTime = Date.now();
          let assistantMessage = null;
          let assistantMessageAddedToChat = false;
          let accumulatedContentForAutoReply = '';
          if (!isAutoReply) {
              assistantMessage = { role: 'assistant', content: '', model: settingsToUse.model, timestamp: new Date().toISOString(), elapsedTime: 0, isStreaming: isStreaming };
          }
          const resetUiStates = (focusInput = true) => {
              this.app.STATE.isWaitingForResponse = false;
              this.app.DOM.sendBtn.removeClass('sending').prop('disabled', false);
              this.app.DOM.messageInput.prop('disabled', false);
              if (focusInput && !isAutoReply && !this.app.DOM.messageInput.is(':focus')) {
                  this.app.DOM.messageInput.trigger('focus');
              }
          };
          await this._makeApiRequest({
              endpoint, requestData, isStreaming,
              onNonStreamSuccess: (data) => {
                  if (isAutoReply) {
                      if (data.response && data.response.trim() !== '') {
                          this.app.DOM.messageInput.val(data.response);
                          resetUiStates(false);
                          const elapsedTime = Date.now() - requestStartTime;
                          const meta = { elapsedTime, isStreaming: settingsToUse.isStreaming, model: settingsToUse.model };
                          this.sendChatMessage(null, false, meta);
                      } else {
                          this.app.ui.notification.warning('自动回复未返回有效内容。');
                          resetUiStates();
                      }
                  } else {
                      const userMessages = chat.messages.filter(m => m.role === 'user');
                      const lastUserMessageSent = userMessages[userMessages.length - 1];
                      assistantMessage.content = data.response;
                      assistantMessage.elapsedTime = lastUserMessageSent ? (Date.now() - lastUserMessageSent.sentTime) : 0;
                      chat.messages.push(assistantMessage);
                      this.app.data.saveChats();
                      this.app.ui.renderChatMessages(chat.messages);
                  }
              },
              onStreamDelta: (parsedDelta) => {
                  if (isAutoReply) {
                      accumulatedContentForAutoReply += parsedDelta.delta;
                  } else {
                      if (!assistantMessageAddedToChat) {
                          chat.messages.push(assistantMessage);
                          assistantMessageAddedToChat = true;
                      }
                      assistantMessage.content += parsedDelta.delta;
                      this.app.ui.renderChatMessages(chat.messages);
                  }
              },
              onStreamFinish: (parsedFinish) => {
                  if (isAutoReply) {
                      if (parsedFinish.status === 'finish' && parsedFinish.delta) accumulatedContentForAutoReply += parsedFinish.delta;
                      if (accumulatedContentForAutoReply.trim() !== '') {
                          this.app.DOM.messageInput.val(accumulatedContentForAutoReply.trim());
                          resetUiStates(false);
                          const elapsedTime = Date.now() - requestStartTime;
                          const meta = { elapsedTime, isStreaming: settingsToUse.isStreaming, model: settingsToUse.model };
                          this.sendChatMessage(null, false, meta);
                      } else {
                          this.app.ui.notification.warning('自动回复未返回有效内容。');
                           resetUiStates();
                      }
                  } else {
                      let saveAndRender = false;
                      if (assistantMessageAddedToChat) {
                          if (assistantMessage.content.trim() === '') {
                              const idx = chat.messages.indexOf(assistantMessage);
                              if (idx > -1) chat.messages.splice(idx, 1);
                          } else {
                               const userMessages = chat.messages.filter(m => m.role === 'user');
                               const lastUserMsg = userMessages[userMessages.length - 1];
                               assistantMessage.elapsedTime = lastUserMsg ? (Date.now() - lastUserMsg.sentTime) : 0;
                          }
                          saveAndRender = true;
                      } else if (parsedFinish.status === 'finish' && parsedFinish.delta && parsedFinish.delta.trim() !== '') {
                          assistantMessage.content = parsedFinish.delta;
                          const userMessages = chat.messages.filter(m => m.role === 'user');
                          const lastUserMsg = userMessages[userMessages.length - 1];
                          assistantMessage.elapsedTime = lastUserMsg ? (Date.now() - lastUserMsg.sentTime) : 0;
                          chat.messages.push(assistantMessage);
                          saveAndRender = true;
                      }
                      if (saveAndRender) {
                          this.app.data.saveChats();
                          this.app.ui.renderChatMessages(chat.messages);
                      }
                  }
              },
              onError: (error) => {
                  console.error(`API Error (${isAutoReply ? 'Auto-Reply' : 'Chat'}):`, error);
                  this.app.ui.notification.error(`${isAutoReply ? '自动回复' : '请求'}失败: ${error.message}`);
                  if (!isAutoReply && assistantMessageAddedToChat) {
                      const idx = chat.messages.indexOf(assistantMessage);
                      if (idx > -1) chat.messages.splice(idx, 1);
                      this.app.ui.renderChatMessages(chat.messages);
                  }
              },
              onFinally: () => {
                  if (!isAutoReply) {
                      resetUiStates();
                  } else {
                      if (this.app.DOM.sendBtn.hasClass('sending')) {
                          resetUiStates();
                      }
                  }
              }
          });
      }
      sendChatMessage(contentOverride = null, isResend = false, autoReplyMeta = null) {
          this._prepareAndSendApiRequest(false, contentOverride, isResend, autoReplyMeta);
      }
      sendAutoReplyRequest() {
          this._prepareAndSendApiRequest(true);
      }
    }
    class EventHandlerManager {
        constructor(app) {
            this.app = app;
        }
        attachEventListeners() {
            this.app.DOM.sidebarToggleBtn.on('click', this.handleSidebarToggleClick.bind(this));
            this.app.DOM.sendBtn.on('click', this.handleSendMessageClick.bind(this));
            this.app.DOM.messageInput.on('keypress', this.handleMessageInputKeypress.bind(this));
            this.app.DOM.newChatBtn.on('click', () => this.app.data.createNewChat());
            this.app.DOM.newChatBtnBottom.on('click', () => this.app.data.createNewChat());
            this.app.DOM.settingsBtn.on('click', () => this.app.ui.showSettingsPanel());
            this.app.DOM.closeSettingsBtn.on('click', () => this.app.ui.hideSettingsPanel());
            this.app.DOM.settingsOverlay.on('click', () => this.app.ui.hideSettingsPanel());
            this.app.DOM.closeModalBtn.on('click', () => this.app.ui.hideConfirmationModal());
            this.app.DOM.cancelDeleteBtn.on('click', () => this.app.ui.hideConfirmationModal());
            this.app.DOM.confirmDeleteBtn.on('click', () => this.app.data.confirmChatDeletion());
            this.app.DOM.modelSelectorBtn.on('click', (e) => this.app.ui.toggleModelSelectorDropdown(e));
            $(document).on('click', '.model-selector-option', (event) => {
                 if ($(event.currentTarget).closest(this.app.DOM.modelOptionsContainer).length) {
                    this.app.ui.selectModelOption($(event.currentTarget).data('value'));
                 }
            });
            $(document).on('click', this.handleDocumentClickForModelSelector.bind(this));
            this.app.DOM.saveSettingsBtn.on('click', () => this.app.data.saveCurrentChatSettings());
            this.app.DOM.historyList.on('click', '.history-item', this.handleHistoryItemClick.bind(this));
            this.app.DOM.historyList.on('click', '.delete-btn', this.handleHistoryDeleteClick.bind(this));
            this.app.DOM.historyList.on('dblclick', '.history-name', this.handleHistoryNameDblClick.bind(this));
            this.app.DOM.historyList.on('focusout', '.edit-name-input', this.handleHistoryEditFocusOut.bind(this));
            this.app.DOM.historyList.on('keypress', '.edit-name-input', this.handleHistoryEditKeyPress.bind(this));
            this.app.DOM.chatContainer.on('dblclick', '.user-message', this.handleUserMessageDblClick.bind(this));
            this.app.DOM.chatContainer.on('click', '.edit-message-container .cancel-button', this.handleCancelEditUserMessageClick.bind(this));
            this.app.DOM.chatContainer.on('click', '.edit-message-container .save-button', this.handleSaveEditedUserMessageClick.bind(this));
            this.app.DOM.chatContainer.on('click', '.resend-btn', this.handleResendMessageClick.bind(this));
            this.app.DOM.chatContainer.on('click', '.auto-reply-button', this.handleAutoReplyClick.bind(this));
            this.app.DOM.chatContainer.on('click', '.assistant-think-toggle, .user-think-toggle', function () {
                const $this = $(this);
                $this.toggleClass('open');
                const $parentContainer = $this.closest('.user-think-container, .assistant-think-container');
                let contentClass = '';
                if ($parentContainer.hasClass('user-think-container')) contentClass = '.user-think-content';
                else if ($parentContainer.hasClass('assistant-think-container')) contentClass = '.assistant-think-content';
                if (contentClass) $parentContainer.find(contentClass).toggleClass('show');
            });
            this.app.DOM.userProfileBtn.on('click', this.handleUserProfileBtnClick.bind(this));
            this.app.DOM.startChatBtn.on('click', this.handleStartChatBtnClick.bind(this));
            this.app.DOM.usernameInput.on('input', this.handleUsernameInput.bind(this));
            $(window).on('resize', Utils.debounce(this.handleWindowResize.bind(this), 200));
            this.app.DOM.tabButtons.on('click', this.handleTabButtonClick.bind(this));
            if (this.app.DOM.messageInput && this.app.DOM.messageInput.length) {
                this.app.DOM.messageInput.on('input', this.app.ui.adjustTextareaHeight.bind(this.app.ui));
                this.app.DOM.messageInput.on('input', this.handleMessageInputDraftSave.bind(this));
            }
        }
        handleSidebarToggleClick() {
            const sidebar = this.app.DOM.sidebar;
            const isMobile = this.app.STATE.isMobileView;
            let stateKey = isMobile ? 'sidebarMobileState' : 'sidebarDesktopState';
            sidebar.toggleClass('collapsed');
            localStorage.setItem(stateKey, sidebar.hasClass('collapsed') ? 'collapsed' : 'expanded');
        }
        handleWindowResize() {
            const newIsMobile = window.innerWidth <= 768;
            if (newIsMobile !== this.app.STATE.isMobileView) {
                this.app.STATE.isMobileView = newIsMobile;
                this.app._applySidebarStateBasedOnScreen();
            }
        }
        handleSendMessageClick() { this.app.api.sendChatMessage(); }
        handleMessageInputKeypress(event) {
            if (event.key === 'Enter' && !event.shiftKey && !this.app.STATE.isWaitingForResponse) {
                event.preventDefault();
                this.app.api.sendChatMessage();
            }
        }
        handleDocumentClickForModelSelector(event) {
            if (!$(event.target).closest('.model-selector').length && this.app.DOM.modelSelector.hasClass('open')) {
                this.app.DOM.modelSelector.removeClass('open');
                this.app.DOM.modelSelectorBtn.find('i').removeClass('rotate-180');
            }
        }
        handleHistoryItemClick(event) {
            const $historyItem = $(event.currentTarget);
            if ($(event.target).closest('.delete-btn').length || $historyItem.hasClass('editing')) return;
            this.app.data.loadChatById($historyItem.data('chat-id'));
        }
        handleHistoryDeleteClick(event) {
            event.stopPropagation();
            const chatId = $(event.currentTarget).closest('.history-item').data('chat-id');
            this.app.ui.showConfirmationModal(chatId);
        }
        handleHistoryNameDblClick(event) {
            event.stopPropagation();
            const $historyItem = $(event.currentTarget).closest('.history-item');
            if (!$historyItem.hasClass('editing')) this.app.ui.startEditingChatName($historyItem);
        }
        handleHistoryEditFocusOut(event) {
            const $historyItem = $(event.currentTarget).closest('.history-item');
            if ($historyItem.hasClass('editing')) this.app.ui.finishEditingChatName($historyItem);
        }
        handleHistoryEditKeyPress(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                const $historyItem = $(event.currentTarget).closest('.history-item');
                this.app.ui.finishEditingChatName($historyItem);
            }
        }
        handleUserMessageDblClick(event) {
            const $userMessageDiv = $(event.currentTarget);
            const $messageElement = $userMessageDiv.closest('[data-message-index]');
            const messageIndex = parseInt($messageElement.data('message-index'));
            const chat = this.app.data.getCurrentChat();
            if (chat && chat.messages[messageIndex] && chat.messages[messageIndex].isAutoReply) {
                return;
            }
            this.app.ui.startEditUserMessage($userMessageDiv, messageIndex);
        }
        handleCancelEditUserMessageClick(event) {
            this.app.ui.cancelEditUserMessage(event.currentTarget);
        }
        handleSaveEditedUserMessageClick(event) {
            const $button = $(event.currentTarget);
            const $messageElement = $button.closest('[data-message-index]');
            const messageIndex = parseInt($messageElement.data('message-index'));
            this.app.ui.saveEditedUserMessage(event.currentTarget, messageIndex);
        }
        handleResendMessageClick(event) {
            event.stopPropagation();
            const messageIndex = parseInt($(event.currentTarget).data('message-index'));
            this.app.data.resendUserMessage(messageIndex);
        }
         handleAutoReplyClick(event) {
            event.stopPropagation();
            const $button = $(event.currentTarget);
            const $messageElement = $button.closest('[data-message-index]');
            const messageIndex = parseInt($messageElement.data('message-index'));
            const chat = this.app.data.getCurrentChat();
            if (!chat || messageIndex < 0 || messageIndex >= chat.messages.length) return;
            chat.messages = chat.messages.slice(0, messageIndex + 1);
            this.app.data.saveChats();
            this.app.ui.renderChatMessages(chat.messages);
            this.app.api.sendAutoReplyRequest();
        }
        handleUserProfileBtnClick() {
            this.app.ui.showUserLoginModal();
        }
        handleStartChatBtnClick() {
            const username = this.app.DOM.usernameInput.val().trim();
            if (username) {
                localStorage.setItem('currentUser', username);
                this.app.STATE.currentUser = username;
                this.app.ui.updateUserProfileAvatar(username);
                this.app.ui.hideUserLoginModal();
            } else {
                this.app.ui.notification.error('用户名不能为空');
            }
        }
        handleUsernameInput() {
            const username = this.app.DOM.usernameInput.val().trim();
            this.app.DOM.startChatBtn.prop('disabled', !username);
        }
        handleTabButtonClick(event) {
            const tab = $(event.currentTarget).data('tab');
            this.app.ui.switchSettingsTab(tab);
        }
        handleMessageInputDraftSave() {
            localStorage.setItem('draftMessage', this.app.DOM.messageInput.val());
        }
    }
    class App {
        constructor() {
            this.DOM = {};
            this.STATE = {
                currentChatId: null,
                isWaitingForResponse: false,
                chatToDelete: null,
                isNewChat: false,
                currentModel: defaultAssistantSettings.model,
                chats: [],
                isMobileView: window.innerWidth <= 768,
                currentSettingsTab: 'assistant'
            };
            this.MODEL_INFO = {
                'community-finance-qwen3': { name: 'community-finance-qwen3', description: "Qwen3" },
                'community-finance-qwen-72b': { name: 'community-finance-qwen-72b', description: "PnganGPT" },
                'community-finance-ai': { name: 'community-finance-ai', description: "DeepSeek R1 32B" }
            };
            this.data = new DataManager(this);
            this.ui = new UIManager(this);
            this.api = new APIManager(this);
            this.eventHandlers = new EventHandlerManager(this);
        }
        _applySidebarStateBasedOnScreen() {
            let savedStateKey = this.STATE.isMobileView ? 'sidebarMobileState' : 'sidebarDesktopState';
            let savedState = localStorage.getItem(savedStateKey);
            let shouldBeCollapsed;
            if (this.STATE.isMobileView) {
                shouldBeCollapsed = (savedState === null) ? true : (savedState === 'collapsed');
            } else {
                shouldBeCollapsed = (savedState === 'collapsed');
            }
            this.DOM.sidebar.toggleClass('collapsed', shouldBeCollapsed);
        }
        _populateModelSelectorOptions() {
            this.DOM.modelOptionsContainer.empty();
            const templateHtml = this.DOM.modelSelectorOptionTemplate;
            if (!templateHtml) {
                console.error("Model selector option template not found!");
                return;
            }
            Object.keys(this.MODEL_INFO).forEach(modelKey => {
                const modelData = this.MODEL_INFO[modelKey];
                const $option = $(templateHtml);
                $option.attr('data-value', modelKey);
                $option.find('.model-name').text(modelData.name);
                $option.find('.model-description').text(modelData.description);
                this.DOM.modelOptionsContainer.append($option);
            });
        }
        init() {
            this.DOM = {
                sidebar: $('#sidebar'),
                sidebarToggleBtn: $('#sidebar-toggle-btn'),
                historyList: $('#history-list'),
                chatContainer: $('#chat-container'),
                messageInput: $('#message-input'),
                sendBtn: $('#send-btn'),
                newChatBtn: $('#new-chat-btn'),
                newChatBtnBottom: $('#new-chat-btn-bottom'),
                settingsBtn: $('#settings-btn'),
                userProfileBtn: $('#user-profile-btn'),
                loggedInUsername: $('#current-username'),
                userLoginModal: $('#user-login-modal'),
                usernameInput: $('#username-input'),
                startChatBtn: $('#start-chat-btn'),
                confirmModal: $('#confirm-modal'),
                closeModalBtn: $('#close-modal-btn'),
                cancelDeleteBtn: $('#cancel-delete-btn'),
                confirmDeleteBtn: $('#confirm-delete-btn'),
                modelSelectorBtn: $('#model-selector-btn'),
                selectedModelDisplay: $('#selected-model'),
                modelSelector: $('.model-selector'),
                modelOptionsContainer: $('#model-options-container'),
                settingsPanel: $('#settings-panel'),
                settingsOverlay: $('#settings-overlay'),
                closeSettingsBtn: $('#close-settings-btn'),
                streamingToggle: $('#streaming-toggle'),
                systemInstructionInput: $('#system-instruction-input'),
                temperatureInput: $('#temperature-input'),
                topPInput: $('#top-p-input'),
                topKInput: $('#top-k-input'),
                repetitionPenaltyInput: $('#repetition-penalty-input'),
                streamingEndpointInput: $('#streaming-endpoint-input'),
                nonStreamingEndpointInput: $('#non-streaming-endpoint-input'),
                saveSettingsBtn: $('#save-settings-btn'),
                userMessageTemplate: $('#user-message-template').html(),
                assistantMessageTemplate: $('#assistant-message-template').html(),
                historyItemTemplate: $('#history-item-template').html(),
                historySectionTemplate: $('#history-section-template').html(),
                notificationTemplate: $('#notification-template').html(),
                initialChatEmptyStateTemplate: $('#initial-chat-empty-state-template').html(),
                historyListEmptyStateTemplate: $('#history-list-empty-state-template').html(),
                modelSelectorOptionTemplate: $('#model-selector-option-template').html(),
                chatTitle: $('#chat-title'),
                tabButtons: $('.tab-button'),
                sharedSettingsForm: $('#shared-settings-form')
            };
            this._populateModelSelectorOptions();
            this.DOM.modelOptions = this.DOM.modelOptionsContainer.find('.model-selector-option');
            this.STATE.chats = JSON.parse(localStorage.getItem('chats')) || [];
            this.ui.notification.init();
            this._applySidebarStateBasedOnScreen();
            this.ui.renderChatHistory();
            const storedCurrentChatId = localStorage.getItem('currentChatId');
            let chatToLoad = null;
            if (storedCurrentChatId) {
                chatToLoad = this.STATE.chats.find(chat => chat.id === storedCurrentChatId);
            }
            if (chatToLoad) {
                this.data.loadChatById(chatToLoad.id);
            } else if (this.STATE.chats.length > 0) {
              const sortedChatsOnInit = [...this.STATE.chats].sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
              this.data.loadChatById(sortedChatsOnInit[0].id);
            } else {
                this.data.createNewChat();
            }
            this.STATE.currentUser = localStorage.getItem('currentUser');
            if (!this.STATE.currentUser) {
                this.ui.showUserLoginModal();
            } else {
                this.ui.updateUserProfileAvatar(this.STATE.currentUser);
            }
            this.eventHandlers.attachEventListeners();
            this.ui.adjustTextareaHeight();
            const savedDraft = localStorage.getItem('draftMessage');
            if (savedDraft) {
                this.DOM.messageInput.val(savedDraft);
                this.ui.adjustTextareaHeight();
            }
            this.DOM.messageInput.trigger('focus');
        }
    }
    let app;
    $(document).ready(() => {
        app = new App();
        app.init();
    });
  </script>
</body>
</html>